# 트리<br>

## 특징

검색의 편리함<br>

논리적 계층을 갖고 있다<br>

계급적 특성을 갖고있다<br><br>

## 구성

### 노드

트리의 항목 / 트리에 저장되는 데이터의 묶음 (값과 link)<br><br>

### 부모노드 - 자식노드

상하 계층구조가 있고, **직접적으로 연결되 노드**로서 상위계층의 부모노드와 하위계층의 자식 노드<br>

(중간에 누가 껴있으면, 부모-자식 관계라 칭하지 않는다)<br><br>

### 루트노드

트리의 최상위 노드 (부모가 없는 노드)<br>

### 서브트리

부모 노드를 삭제하면 생기는 트리들 (자손 node로만 구성됨)<br>

### 리프(leaf)노드

트리의 맨 끝(바닥)에 있으면서, 자신의 서브트리를 갖지 않는 노드<br>

= 자식노드가 없는 맨 끝놈들<br><br>

## 진입/진출 차수

진입차수 : 나한테 오는 차수 (부모노드의 유무)<br>

진출차수: 나로부터 나가는 차수 (자식노드의 유무)<br>

- 루트노드 : 진입차수 0
- 루트를 제외한 모든 노드의 진입차수 : 1

    (부모가 1개만 있어야 트리이기에)

- 리프노드: 진출차수 0

## 트리의 레벨/높이<br>

### 노드의 레벨

루트로부터 그 노드까지 이어진 선(경로, 간선)의 길이<br><br>

### 트리의 높이

루트로부터 가장 멀리 있는 노드까지 이어진 선(경로)의 길이에 1을 더한 값<br>

(레벨이 인덱스처럼 0부터 시작한다면, 높이는 일반 숫자마냥 1부터 시작한다)<br><br>

# 이진트리

## 정의

모든 노드의 차수가 **2 이하**인 트리<br>

모든 노드가 2개 이하의 자식 노드를 가지므로 일반성을 잃지 않고, "오른쪽", "왼쪽"이라는 방향 개념을 부여할 수 있다<br>

= 오른쪽 노드, 왼쪽 노드 식의 개념적 접근도 가능<br>

## 포화 이진 트리

이진트리의 각 레벨에서 허용되는 최대 갯수(2개) 노드를 가지는 트리<br>

## 완전 이진 트리

높이가 k인 이진 트리가 "0레벨"부터 "k-2레벨"까지 다 채우고, 마지막 "k-1레벨"에서 왼쪽부터 오른쪽으로 노드들이 차례로 채워진 이진트리<br>

즉 왼쪽에서부터 채워나가는 트리..<br><br>

## 배열을 이용한 이진 트리의 구현

트리가 **완전 이진 트리 또는 포화 이진트리**일 경우 낭비되는 공간이 없이 효율적이다<br>

허나, 트리가 깊어질수록 메모리의 낭비가 2의 거듭제곱에 비례하여 낭비가 심해진다<br><br>

## 포인터를 이용한 이진 트리의 구성

이진트리기에 link field는 left, right 2개이다<br>

M, P, E는 leaf로 더 내려갈 곳이 없기에 좌우측의 pointer가 null상태이다<br><br>

## 이진트리의 순회

이진트리의 각 노드를 (빠짐없이 그리고 중복없이) 한번 씩 방문하는 것<br>

ex)왼쪽에 자식이 있으면 → 출력하고 다시 아래로 이동 → 왼쪽에 자식이 있으면 → 출력하고 다시 아래로 이동...<br>

⇒ 재귀 함수 적으로 움직인다<br>

### 전위 순회(PLR)

**루트노드 - 왼쪽 자식노드 - 오른쪽 자식노드** 순으로 순회하는 것<br>

1. 루트를 방문
2. 왼쪽 서브트리를 전위 순회로 순회
3. 오른쪽 서브트리를 전위 순회로 순회<br>

### 후위 순회(LRP)

**왼쪽 자식노드 - 오른쪽 자식노드 - 루트노드** 순으로 순회하는 것<br>

1. 왼쪽 서브트리를 후위 순회로 순회
2. 오른쪽 서브트리를 후위 순회로 순회
3. 루트를 방문<br>

### 중위 순회(LPR)

**왼쪽 자식노드 - 루트노드 - 오른쪽 자식노드** 순으로 순회하는 것<br>

1. 왼쪽 서브트리를 중위 순회로 순회
2. 루트를 방문
3. 오른쪽 서브트리를 중위 순회로 순회<br><br>

## 이진트리의 생성 / 삽입 / 삭제

일반적인 이진트리를 생성하는 것은 단순 연결 리스트 연산을 사용한다<br>

첫 노드를 생성하면 루트노드가 되고,<br>

새로운 노드를 추가하려면 "연결리스트의 삽입 연산"을 이용한다<br>