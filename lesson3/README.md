# Search

## 검색을 하는 3가지 예
- 배열 검색 ⬅️ 오늘 진행
- 선형 리스트 검색
- 이전 검색트리 검색
<br>

## 배열 검색의 알고리즘
1. 선형 검색
**무작위**로 늘어놓은 데이터 모임에서 검색을 수행한다
2. 이진 검색
**일정한 규칙**으로 늘여놓은 데이터 모임에서 아주 빠른 검색을 수행한다
3. 해시법
**추가, 삭제가 자주 일어나는** 데이터 모임에서 아주 빠른 검색을 수행
    - 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
    - 오픈 주소법 : 데이터를 위한해시 값이 충돌할 때 재해시 하는 방법
<br>

## 선형 검색
요소가 직선 모양으로 늘어선 배열에서 원하는 키 값을 갖는 요소를 만날 때 까지 맨 앞부터 순서대로 요소를 검색한다.
검사 비용 크다.
<br>

**종료조건**
1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
2. 검색할 값과 같은 요소를 발견한 경우
<br>

## 보초법
배열 내에 검색하고자 하는 키 값을 맨 끝 요소로 저장한다.
검색 종료 판단 조건이 1가지로 줄어든다 (같은 요소 발견한 경우)
<br>

## 이진 검색
요소가 오름차순 또는 내림 차순으로 정렬된 배열에서 중앙값을 기준으로 검색 요소와 대조하는 방법.
선형 검색보다 빠르게 검색할 수 있다.
<br>

**종료조건**
1. 검색 범위가 더 이상 없는 경우
2. 검색할 값과 같은 요소를 발견한 경우
<br>
<br>

# 복잡도
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도라고 한다.
복잡도는 두가지 요소를 가지고 있다.
1. 시간 복잡도(time complexity)<br>
    실행에 필요한 시간을 평가한 것<br>

2. 공간 복잡도(space complexity)<br>
    기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
<br>
<br>

## 복잡도 표시(Big-0)
n에 비례하는 횟수만큼 실행하는 경우의 복잡도를 O(n)으로 표시한다.
<br>
*O(n)은 "O-n", "Order n", "n의 Order"라고 읽는다..!
<br>
<br>

**앞에 붙는 상수는 무시한다**<br>
ex) O(2n) => O(n)<br>
why?) **Big-O 표기법은 장기적인 데이터 증가에 따른 처리시간의 증가율을 예측하기 위해 만들어진 표기법.** <br>
상수는 고정된 숫자기에 증가율에 영향을 미칠 때 언제나 **고정된 상수만큼만** 영향을 미친다.<br>
<br>

`O(n)`
<br>

입력 **데이터의 크기에 비례하여 처리시간이 걸리는** 알고리즘을 표기할 때 사용한다.<br>
데이터의 크기와 처리시간이 비례하여 증가한다.<br>
<br>

`O(1)`
<br>

**입력 데이터 크기에 상관없이 언제나 일정한 시간이 걸리는** 알고리즘을 표기할 때 사용한다.<br> 
일정한 시간이 걸리기에 데이터 크기가 커져도 처리 시간이 변하지 않는다.<br>
<br>

`O(n2)` - n의 제곱<br>
루프 안에서 또 **같은 변수** 크기 만큼 루프를 돌릴 때.
루프를 중첩시켜서 돌리기에, 처리시간이 `n*n` = n의 제곱만큼 발생한다.<br><br>

`O(nm)`<br>

루프 안에서 **다른 변수** 크기 만큼 돌릴 때.<br>
```
F(int[] n, int[] m){
    for i = 0 to n.length
        for j = 0 to m.length
            print i + j
}
```
<br>
n개를 m번 돌리니까 처리시간이 `n*m` = nm만큼 걸리게 된다<br><br>

`O(2n)` - 2의 n승<br>
재귀함수 사용 시 한 함수를 호출할 때마다 두번씩 재귀가 일어나는 경우..<br>
데이터의 양이 늘어남에 따라 처리 시간이 매우 급속히 증가한다.<br>
재귀가 m번 일어나면 m의 n승으로 표기하면 된다.<br><br>

`O(log n)`<br>
대표 : 이진검색<br>
한번 처리할 때마다 검색해야 될 **데이터가 절반씩 뚝뚝 떨어지는 알고리즘**을 표현한다.<br>
속도가 `O(n)`보다 현저히 빠르다.<br>
데이터가 커져도 성능이 크게 차이나지 않는다.<br>
<br>
<br>

`O(sqrt(n))`<br>
square root = 제곱근<br>
즉 제곱근만큼만 알고리즘.<br>
9를 넣었는데 3만 진행하듯이.
<br>
<br>

**Tip)**<br>
2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시 한다.


