# 힙 heap = 우선순위 큐를 이진트리로 구현한 것

피라미드 모양으로 쌓아 올린 더미<br>

무엇인가를 쌓아놓은 더미이고 항상 가장 위에 있는 것을 꺼내는 구조<br>

**부모-자식 노드 사이(부분적으로)에서 정렬된 완전 이진트리로, 부모노드는 자식노드보다 우선순위가 높다**<br>

부모는 크게, 자식은 작게 만들어야 된다<br>
부모-자식 노드 관계만 본다 (조상간 관계는 신경쓰지 않는댜)<br><br>

## 힙의 추상자료형

부분적으로 정렬된 **완전 이진트리**로 부모노드는 자식노드보다 우선순위가 높다<br>

### 연산

1. insert(element) : 힙에 데이터 삽입
2. remove() : 힙(루트)에서 데이터 삭제
3. peek() : 힙(루트)에서 데이터 읽어오기
4. isEmpty() : 힙이 비었는지 확인
5. size() : 힙에 저장한 데이터 개수 확인<br>

## 힙의 종류

### 최소 힙

**루트가 전체 노드중에서 최소값인 힙 (위로 갈수록 값이 작아진다)**<br>

트리의 모든 노드가 자식노드보다 작은 값을 가진다<br>

루트가 가장 작은 값을 갖고, 부모는 자식보다 작은 값을 가진다<br>

탐색트리처럼 왼쪽 노드, 오른쪽 노드 사이에 크기 차이나 그런거 없음. 좌우따위 신경쓰지 않는다!<br>

### 최대 힙

**루트가 전체 노드중에 최대값인 힙 (위로 갈수록 값이 커진다)**<br>

트리의 모든 노드가 자식 노드보다 큰 값을 가진다<br>

루트가 가장 큰 값을 갖고, 부모는 자식보다 큰 값을 가진다<br>

### 힙이 아닌 경우

1. 완전 이진트리가 아닌 경우
2. 부모가 자식보다 작지 않거나, 자식이 부모보다 작지 않은 경우 (즉..순서가 비일관적인 경우)<br>

## 배열을 이용한 힙의 구현

**완전 이진트리**이기 때문에 배열로 구현해도 메모리 낭비가 없다<br>

연결 리스트보다 실행 속도 면에서 효율적이다<br>


### 힙의 노드 삭제

1. front를 지운다 (=root 값을 지운다)
2. 다음으로 우선순위가 높은 애를 root로 올린다
    1. root / child1 / child2 세가지를 비교해서 가장 작은 값과 root 값 2개를 교체한다
    2. 재귀적으로 진행해서 자식 노드까지 (끝까지) 다 올바르게 고쳐지도록 한다

        (자식노드가 null인 경우 비교하지 않도록 한다)<br>

### 힙의 노드 삽입

노드는 **마지막 leaf node**에 삽입한다!!<br>

1. 완전 이진 트리인지 확인
2. 부모자식 관계가 다른 노드들과 같은지 확인
    1. 같지 않은 경우 부모와 자식간 자리를 교체하기

        재귀적으로 최상단까지 올라간다