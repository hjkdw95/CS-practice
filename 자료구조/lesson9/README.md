# 연결리스트(Linked List)

## 리스트의 의미

"일정한 순서"의 나열<br>

어떤 정의에 의해서 결정된 "논리적인 순서"의 나열<br>

⇒ 리스트의 "**순서**"는 데이터에 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 "**논리적인 순서**", 혹은 리스트에 나타나는 원소들 간의 "**의미적인 순서**"를 의미한다<br>

## 배열과의 차이점

### 배열

인덱스로 표현되는 "순서"가 배열 원소의 메모리 공간에서의 물리적인 위치를 의미한다<br>

인덱스의 순서와 메모리 위치가 1:1로 매치한다<br>

### 리스트

"순서" : 어떤 정의에 의해서 결정된 논리적인 순서<br>

원소들의 물리적인 저장 순서와 위치와는 무관하게 원소들 간의 논리적인 순서만 유지(via pointer)<br>

## 리스트의 구현 방법

- 포인터를 이용한 리스트의 구현 방법 (연결리스트)<br>

    원소값을 저장하는 공간과, **다음 원소를 가리키는 위치 정보 저장 공간(pointer)**를 함께 구현하는 방법<br>

- 배열을 이용한 리스트의 구현 방법 (순서리스트)<br>

# 배열을 이용한 리스트

원소의 순서가 연속적인 물리적 주소에 저장된다<br>

### 한계 / 단점

처음분터 여유롭게 배열을 크게 확장하면 ⇒ 불필요한 메모리가 낭비된다<br>

원소를 리스트 중간에 삽입하기 위해서는 리스트 원소값을 하나씩 밀어야 되어 데이터 이동에 시간이 많이 걸리게 된다 ⇒ 리스트 원소값의 이동은 원소수가 많을 수록 프로그램의 수행시간을 증가시킨다<br>

### 실무에서의 문제점

리스트의 원소 삽입은 프로그램의 실행 중에 메모리 할당을 필요로 하는 경우도 발생시킨다<br>

**자료의 삽입과 삭제가 빈번히 발생하는 상황**에서 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 **비효율적인 컴퓨팅 성능을 유발**<br>

⇒ 배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않는다<br>

# 포인터를 이용한 리스트

## node의 구조

node : 리스트의 원소(값) + 다음 원소를 가리키는 정보<br>

노드는 데이터 요소와 리스트의 다음 원소를 지시하는 포인터(주소, link)로 구성된다